name: Actualizar Infoleg y generar Digesto

on:
  workflow_dispatch:
  schedule:
    - cron: "0 12 * * *"   # corre todos los dÃ­as a las 09:00 Argentina (UTC-3)

jobs:
  actualizar-datos:
    runs-on: ubuntu-latest

    permissions:
      contents: write

    steps:
      - name: Checkout del repositorio
        uses: actions/checkout@v4

      - name: Instalar dependencias
        run: |
          pip install -r requirements.txt


      # ============================================================
      # 1) Descargar Infoleg (datos crudos â†’ /data/)
      # ============================================================
      - name: Ejecutar descargar_infoleg.py
        env:
          APP_KEY: ${{ secrets.APP_KEY }}
          APP_SECRET: ${{ secrets.APP_SECRET }}
          REFRESH_TOKEN: ${{ secrets.REFRESH_TOKEN }}
        run: python scripts/descargar_infoleg.py

      # ============================================================
      # 2) Procesar Infoleg (â†’ genera /data_procesada/)
      # ============================================================
      - name: Ejecutar procesar_infoleg.py
        run: python scripts/procesar_infoleg.py

      # ============================================================
      # 3) BORRAR archivos viejos y SUBIR nuevos
      # ============================================================
      - name: Subir archivos a Dropbox
        env:
          DROPBOX_REFRESH_TOKEN: ${{ secrets.REFRESH_TOKEN }}
          DROPBOX_CLIENT_ID: ${{ secrets.APP_KEY }}
          DROPBOX_CLIENT_SECRET: ${{ secrets.APP_SECRET }}
        run: |
          python - << 'EOF'
          import os, json, requests

          # ---------------------------------------------------------
          # Genera nuevo access token
          # ---------------------------------------------------------
          def obtener_access_token():
              data = {
                  "grant_type": "refresh_token",
                  "refresh_token": os.environ["DROPBOX_REFRESH_TOKEN"],
                  "client_id": os.environ["DROPBOX_CLIENT_ID"],
                  "client_secret": os.environ["DROPBOX_CLIENT_SECRET"],
              }
              r = requests.post("https://api.dropbox.com/oauth2/token", data=data)
              r.raise_for_status()
              return r.json()["access_token"]

          # ---------------------------------------------------------
          # Borrar archivos en una carpeta remota
          # ---------------------------------------------------------
          def borrar_carpeta(token, carpeta):
              url_list = "https://api.dropboxapi.com/2/files/list_folder"
              url_del  = "https://api.dropboxapi.com/2/files/delete_v2"

              headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}

              r = requests.post(url_list, headers=headers, json={"path": f"/{carpeta}"})
              if r.status_code != 200:
                  print(f"No se pudo listar /{carpeta}: {r.text}")
                  return

              for entry in r.json().get("entries", []):
                  ruta = entry["path_lower"]
                  print(f"ðŸ—‘ï¸  Borrando {ruta}")
                  requests.post(url_del, headers=headers, json={"path": ruta})

          # ---------------------------------------------------------
          # Subir archivo
          # ---------------------------------------------------------
          def subir(token, local, remoto):
              headers = {
                  "Authorization": f"Bearer {token}",
                  "Content-Type": "application/octet-stream",
                  "Dropbox-API-Arg": json.dumps({
                      "path": remoto,
                      "mode": "overwrite",
                      "autorename": False
                  })
              }
              with open(local, "rb") as f:
                  data = f.read()
              r = requests.post("https://content.dropboxapi.com/2/files/upload",
                                headers=headers, data=data)
              print(f"â¬†ï¸  {remoto} â†’ {r.status_code}")

          # ---------------------------------------------------------
          # Ejecutar limpieza + subida
          # ---------------------------------------------------------
          token = obtener_access_token()
          carpetas = ["data", "data_procesada"]

          # borrar TODO primero
          for c in carpetas:
              borrar_carpeta(token, c)

          # volver a subir limpio
          root = os.getcwd()
          for c in carpetas:
              ruta_local = os.path.join(root, c)
              if not os.path.exists(ruta_local):
                  continue
              for archivo in os.listdir(ruta_local):
                  local = os.path.join(ruta_local, archivo)
                  remoto = f"/{c}/{archivo}"
                  subir(token, local, remoto)

          EOF
